<?php

/**
 * @file
 * Content Revision Control.
 */

/**
 * Implements hook_menu().
 */
function zariz_menu() {
  $items = array();
  $items['pages-by-snapshot/%entity_object'] = array(
    'load arguments' => array('snapshot'),
    'type' => MENU_CALLBACK,
    'page callback' => 'zariz_get_pages_list_by_snapshot_json',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'title' => 'Pages list',
    'description' => 'Get pages list by Snapshot.'
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function zariz_entity_info() {
  $items['snapshot'] = array(
    'label' => t('Snapshot'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'Snapshot',
    'base table' => 'zariz_snapshot',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'sid',
    ),
    'bundles' => array(
      'snapshot' => array(
        'label' => t('Snapshot'),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
    ),
    'module' => 'zariz',
    'metadata controller class' => 'EntityDefaultMetadataController',
  );
  return $items;
}


/**
 * Create a new branch form an existing one.
 *
 * @param $branch_name
 *   The branch name.
 * @param $parent_branch
 *   Optional; The node ID or object of the original branch.
 */
function zariz_create_branch($branch_name, $parent_branch = FALSE) {
  global $user;

  // Check branch doesn't exist already.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'branch')
    ->propertyCondition('title', $branch_name)
    ->count()
    ->execute();

  if ($result) {
    throw new Exception(format_string('Branch @name already exists', array('@name' => $branch_name)));
  }

  $values = array(
    'type' => 'branch',
    'title' => $branch_name,
    'uid' => $user->uid,
  );
  $node = entity_create('node', $values);

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->{OG_GROUP_FIELD}->set(TRUE);

  if ($parent_branch) {
    $branch_wrapper = entity_metadata_wrapper('node', $parent_branch);
    $branch_id = $branch_wrapper->getIdentifier();

    $wrapper->field_parent_branch->set($parent_branch);

    // Get the last snapshot created in the original branch.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'snapshot')
      ->fieldCondition('nid', $branch_id)
      ->range(0, 1)
      ->propertyOrderBy('sid', 'DESC')
      ->execute();

    if (!empty($result['snapshot'])) {
      $sid = key($result['snapshot']);
      $wrapper->field_snapshot->set($sid);
    }
  }

  $wrapper->save();
  return $wrapper->value();
}

/**
 * Include new content from the parent branch.
 *
 * As we do not duplicate content between branches, we simply update the "Last
 * node" field to point to the latest node in the parent branch.
 *
 * @param $branch_nid
 *   The branch node ID or object.
 */
function zariz_update_content_from_parent_branch($branch_nid) {
  $wrapper = entity_metadata_wrapper('node', $branch_nid);

  if (!$parent_id = $wrapper->field_parent_branch->getIdentifier()) {
    // Nothing to update, as the branch has no parent.
    return;
  }

  // Get the last node ID.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->fieldCondition(field_parent_branch, 'target_id', $parent_id)
    ->range(0, 1)
    ->propertyOrderBy('nid', 'DESC')
    ->execute();

  if (empty($result['node'])) {
    // Parent branch has no content.
    return;
  }

  $last_nid = key($result['node']);
  $wrapper->field_last_node->set($last_nid);
  $wrapper->save();
}

/**
 * Get the node IDs of the parents of the branch, including the node itself.
 *
 * @param $branch_nid
 *   The branch ID or node.
 * @param $include_current
 *   Determines if the current branch should be included. Defaults to TRUE.
 * @param $ids
 *   Internal use; Array of the parent IDs, used in this recursive function.
 *
 * @return
 *   array with the branch node ID, and it's parents. The top most parent is the
 *   last element in the array.
 */
function zariz_get_branch_parents_ids($branch_nid, $include_current = TRUE, $ids = array()) {
  $wrapper = entity_metadata_wrapper('node', $branch_nid);

  $ids = array();
  if (!$ids && $include_current) {
    $branch_node = $wrapper->value();
    $ids[] = $branch_node->nid;
  }


  if (!$parent_node = $wrapper->field_parent_branch->value()) {
    // We reached the top most parent.
    return $ids;
  }

  // Call function, with the parent node.
  $ids = zariz_get_branch_parents_ids($parent_node, $include_current, $ids);
  return $ids;
}

/**
 * Get the snapshot IDs of the parents of the snapshot, including the snapshot itself.
 *
 * @param $snapshot_id
 *   The branch ID or node.
 * @param $strict_snapshot
 *   Determines if the parent snapshot should be the real parent snapshot, or
 *   the last snapshot the exists in the Branch. If using the last snapshot then
 *   the returned values will include content that was inserted or deleted after
 *   the branch was created. If TRUE, then only the content that was created
 *   exactly when the branch was created will be show. Defaults to FALSE.
 *
 * @return
 *   array with the snapshot ID, and it's parents. The top most parent is the
 *   last element in the array.
 */
function zariz_get_snapshot_parents_ids($snapshot_id, $strict_snapshot = FALSE) {
  if ($strict_snapshot) {
    return zariz_get_snapshot_parents_ids_strict($snapshot_id);
  }

  return zariz_get_snapshot_parents_ids_not_strict($snapshot_id);
}


/**
 * Helper function; Return the snapshot parents in strict mode.
 *
 * @param $snapshot_id
 *   The branch ID or node.
 * @param $ids
 *   Internal use. Array of the parent IDs, used in this recursive function.
 *
 * @return
 *   array with the snapshot ID, and it's parents. The top most parent is the
 *   last element in the array.
 *
 * @see zariz_get_snapshot_parents_ids().
 */
function zariz_get_snapshot_parents_ids_strict($snapshot_id, $ids = array()) {
  $wrapper = entity_metadata_wrapper('snapshot', $snapshot_id);
  $ids[] = $snapshot_id;

  if (!$parent_snapshot = $wrapper->field_snapshot->value()) {
    // We reached the top most parent.
    return $ids;
  }

  // Call function, with the parent snapshot.
  $ids = zariz_get_snapshot_parents_ids($parent_snapshot, $ids);
  return $ids;
}

/**
 * Helper function; Return the snapshot parents in a non-strict mode.
 *
 * @param $snapshot_id
 *   The branch ID or node.
 * @param $ids
 *   Internal use. Array of the parent IDs, used in this recursive function.
 *
 * @return
 *   array with the snapshot ID, and it's parents. The top most parent is the
 *   last element in the array.
 *
 * @see zariz_get_snapshot_parents_ids().
 */
function zariz_get_snapshot_parents_ids_not_strict($snapshot_id, $ids = array()) {
  // Get all the parent branches.
  $ids = array($snapshot_id);
  $snapshot = entity_load_single('snapshot', $snapshot_id);
  $branch_ids = zariz_get_branch_parents_ids($snapshot->nid, FALSE);

  foreach ($branch_ids as $branch_id) {
    if ($snapshot = zariz_get_snapshot_from_branch($branch_id)) {
      $ids[] = $snapshot->sid;
    }
  }

  return $ids;
}

/**
 * Get content by latest snapshot of a branch.
 *
 * @param $branch_id
 *   The branch node ID.
 *
 * @return
 *   Array keyed with:
 *   - last_ids: array keyed by the branch node ID and the last entity ID as
 *     value.
 *   - deleted_ids: array of entity IDs.
 *
 * @see zariz_get_content_by_snapshot()
 */
function zariz_get_content_by_branch($branch_id, $last_id_field_name = 'field_last_node', $strict_snapshot = FALSE) {
  if (!$snapshot = zariz_get_snapshot_from_branch($branch_id)) {
    return;
  }

  return zariz_get_content_by_snapshot($snapshot->sid, $last_id_field_name, $strict_snapshot);
}

/**
 * Return array with the last entity IDs per branch, and the deleted entity IDs.
 *
 * @param $snapshot_id
 *   The snapshot ID.
 * @param $last_id_field_name
 *   The name of the field that holds the last entity ID. Defaults to
 *   "field_last_node".
 * @param $deleted_ids_field_name
 *   The name of the field that holds the the "deleted" entity ID. Defaults to
 *   "field_deleted_nodes".
 * @param $strict_snapshot
 *   Determines if the parent snapshot should be the real parent snapshot, or
 *   the last snapshot the exists in the Branch. If using the last snapshot then
 *   the returned values will include content that was inserted or deleted after
 *   the branch was created. If TRUE, then only the content that was created
 *   exactly when the branch was created will be show. Defaults to FALSE.
 *
 * @return
 *   Array keyed with:
 *   - last_ids: array keyed by the branch node ID and the last entity ID as
 *     value.
 *   - @todo: deleted_ids: array of entity IDs.
 */
function zariz_get_content_by_snapshot($snapshot_id, $last_id_field_name = 'field_last_node', $strict_snapshot = FALSE) {
  $sids = zariz_get_snapshot_parents_ids($snapshot_id, $strict_snapshot);

  $snapshots = entity_load('snapshot', $sids);

  $return = array('last_ids' => array(), 'deleted_ids' => array());
  foreach ($snapshots as $snapshot) {
    $wrapper = entity_metadata_wrapper('snapshot', $snapshot);
    $branch_id = $snapshot->nid;
    $return['last_ids'][$branch_id] = $wrapper->{$last_id_field_name}->getIdentifier();

    // @todo: Return deleted items.
  }

  return $return;
}

/**
 * Page callback; Return pages list by snapshot in JSON.
 *
 * @param Snapshot $snapshot
 *   The Snapshot entity.
 */
function zariz_get_pages_list_by_snapshot_json(Snapshot $snapshot) {
  drupal_json_output(zariz_get_page_list_by_snapshot($snapshot));
}

/**
 * Get a page list of inserted and deleted items, from a single snapshot.
 *
 * @todo: Deal with all entities, not just node.
 *
 * @param $snapshot_id
 *   The snapshot ID or object.
 *
 * @return
 *   Array keyed by "insert" or "deleted" and the URL as value.
 */
function zariz_get_page_list_by_snapshot($snapshot_id) {
  $wrapper = entity_metadata_wrapper('snapshot', $snapshot_id);
  $snapshot = $wrapper->value();

  $branch_id = $snapshot->nid;
  $last_nid = $wrapper->field_last_node->getIdentifier();

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->entityCondition('entity_id', $last_nid, '<=')
    ->fieldCondition('field_branch', 'target_id', $branch_id);

  // Snapshot has a parent, so don't include its values.
  if (!empty($snapshot->parent_sid)) {
    $parent_wrapper = entity_metadata_wrapper('snapshot', $snapshot->parent_sid);
    $query->entityCondition('entity_id', $parent_wrapper->field_last_node->getIdentifier(), '>');
  }

  $result = $query->execute();

  $return = array('insert' => array(), 'delete' => array());

  if (empty($result['node'])) {
    return $return;
  }

  $urls = array();
  foreach (array_keys($result['node']) as $nid) {
    $urls[] = drupal_get_path_alias('node/' . $nid);
  }

  // @todo: Invoke hook.
  // Include the home page.
  $urls[] = 'index.php';

  $return['insert'] = $urls;
  return $return;
}

/**
 * Get the node IDs of "deleted" nodes, that should be excluded.
 *
 * @param $branch_nid
 *   The branch node.
 * @return
 *   array with the node IDs.
 */
function zariz_get_deleted_node_ids($branch_nid) {
  $branch_ids = zariz_get_branch_parents_ids($branch_nid);

  // Get all the deleted node IDs in the branches.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->fieldCondition('field_deleted', 'value', TRUE)
    ->fieldCondition(field_branch, 'target_id', $branch_ids, 'IN')
    ->execute();

  if (empty($result['node'])) {
    return array();
  }

  // Load all the deleted nodes, to get their UUID, so we can exclude also their
  // non-deleted version.
  $uuids = array();
  foreach (node_load_multiple(array_keys($result['node'])) as $node) {
    $wrapper = entity_metadata_wrapper('node', $node);
    $uuid = $wrapper->field_uuid->value();
    $uuids[$uuid] = TRUE;
  }

  // Now query for the nodes, based on the UUID in the parent branches.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->fieldCondition(field_branch, 'target_id', $branch_ids, 'IN')
    ->fieldCondition('field_uuid', 'value', array_keys($uuids), 'IN')
    ->execute();

  return array_keys($result['node']);
}

/**
 * Implements hook_field_access().
 */
function zariz_field_access($op, $field, $entity_type, $entity, $account) {
  $field_names = array(
    'field_merged_branches',
    'field_uuid',
  );
  if ($op == 'edit' && in_array($field['field_name'], $field_names)) {
    return FALSE;
  }
}

/**
 * Implements hook_node_presave().
 *
 * Populate a unique ID value.
 */
function zariz_node_presave($node) {
  if (!empty($node->nid)) {
    return;
  }

  if (!og_is_group_content_type('node', $node->type)) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if (!$uuid = $wrapper->field_uuid->value()) {
    // UUID doesn't exist.
    $uuid = md5(rand());
    $wrapper->field_uuid->set($uuid);
  }
}

/**
 * Implements hook_node_insert().
 *
 * Add node to branch's flag.
 */
function zariz_node_insert($node) {
  if (!og_is_group_content_type('node', $node->type)) {
    // Not a group content.
    return;
  }

  if (!empty($node->_skip_create_snapshot)) {
    // Node explicetly set to skip snapshot creation. This can be used by
    // implementing modules that want for example to create several nodes and
    // only then create a snapshot of them.
    return;
  }

  // Add node to snapshot.
  $wrapper = entity_metadata_wrapper('node', $node);
  $branch_id = $wrapper->field_branch->getIdentifier();
  zariz_snapshot_set_last_entity_id($branch_id, $node->nid);
}

/**
 * Set the last entity ID of a snapshot.
 *
 * @param $branch_id
 *   The branch ID.
 * @parm $id
 *   The entity ID to set as last.
 * @param $field_name
 *   The name of the field that should hold the entity ID..
 * @param Snapshot $snapshot
 *   Optional; The snapshot to set. If NULL, the latest snapshot or a new one
 *   if none found, will be used.
 *
 * @return
 *   The saved Snapshot entity.
 */
function zariz_snapshot_set_last_entity_id($branch_id, $id, $field_name = 'field_last_node', Snapshot $snapshot = NULL) {
  $snapshot = $snapshot ? $snapshot : zariz_get_snapshot_from_branch($branch_id, TRUE);

  $snapshot_wrapper = entity_metadata_wrapper('snapshot', $snapshot);
  $snapshot_wrapper->{$field_name}->set($id);
  $snapshot_wrapper->save();
  return $snapshot;
}

/**
 * Returns the latest snapshot object of a branch.
 *
 * @param $branch_id
 *   The branch ID.
 * @param $create
 *   Determine if a new Snapshot should be created if none exists. $offset
 *   should be set to 0. Defaults to FALSE.
 * @param $offset
 *   The offest from the latest snapshot. Defaults to 0, which is the latest
 *   snapshot created.
 *
 * @return
 *   The Snapshot entity object if found, or un-unsaved Snapshot entity if non
 *   found and $create set to TRUE, or NULL.
 *
 */
function zariz_get_snapshot_from_branch($branch_id, $create = FALSE, $offset = 0) {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'snapshot')
    ->propertyCondition('nid', $branch_id)
    ->range($offset, $offset + 1)
    ->propertyOrderBy('sid', 'DESC')
    ->execute();

  if (empty($result['snapshot'])) {
    if (!$create) {
      return;
    }

    if ($offset) {
      throw new Exception('Offset value should be 0, when calling zariz_get_snapshot_from_branch() with $create set to TRUE.');
    }

    $parent_snapshot = zariz_get_snapshot_from_branch($branch_id, FALSE, 1);

    $values = array(
      'nid' => $branch_id,
      'parent_sid' => !empty($parent_snapshot) ? $parent_snapshot->sid : NULL,
      'created' => time(),
    );
    return entity_create('snapshot', $values);
  }

  $sid = key($result['snapshot']);
  return entity_load_single('snapshot', $sid);
}

/**
 * Implements hook_node_update().
 *
 * Safe guard against updating group content nodes.
 */
function zariz_node_update($node) {
  if (!og_is_group_content_type('node', $node->type)) {
    // Not a group content.
    return;
  }

  if (!empty($node->_allow_save)) {
    // Allow forcing update (e.g. when updating the git hash).
    return;
  }

  // throw new Exception(format_string('Node @title cannot be updated -  a new node should have been created instead.', array('@title' => $node->title)));
}

/**
 * Implements hook_node_delete().
 *
 * Safe guard against deleting any node.
 */
function zariz_node_delete($node) {
  throw new Exception('It is illegal to delete a node.');
}

/**
 * Implements hook_clone_node_alter().
 *
 * Preserve the original node title on clone, and set the branch by context.
 */
function zariz_clone_node_alter($node, $context) {
  if ($context['method'] != 'prepopulate') {
    return;
  }

  if (!$og_context = og_context()) {
    // Safe guard against a failure of PURL to redirect to a group.
    // @todo: Check if this can really happen.
    throw new Exception('Cloning content should be inside a branch context.');
  }


  // Use the original node title.
  $node->title = $context['original_node']->title;

  // Check the context is a child of the existing branch.
  $wrapper = entity_metadata_wrapper('node', $node);
  $new_branch_wrapper = entity_metadata_wrapper('node', $og_context['gid']);

  if ($wrapper->field_branch->getIdentifier() == $og_context['gid']) {
    // We are cloning inside the same branch, which is the only way to update
    // an existing node.
    return;
  }

  if ($new_branch_wrapper->field_branch->getIdentifier() != $wrapper->field_branch->getIdentifier()) {
    $params = array(
      '@origin' => $wrapper->field_branch->label(),
      '@destination' => $new_branch_wrapper->label(),
    );
    throw new Exception(format_string('Cannot clone content from branch @origin to @destination as it was not branched from it.', $params));
  }

  // Set the group audience field according to the existing context. Like this
  // we allow "cherry-picking" content from branch to branch.
  $wrapper->field_branch->set($og_context['gid']);
}


/**
 * Get all nodes of a branch, even if they are not directly in the group.
 *
 * We query for the branch, and the parent branches.
 *
 * @param $branch_nid
 *   A branch node ID. If NULL, OG-context will be triggered to get the current
 *   branch.
 */
function gznt_rn_get_branch_nodes($branch_nid = NULL) {
  if (!$branch_nid && !$og_context = og_context()) {
    throw new Exception('No branch node found to limit the entity field query.');
  }
  $args = array(
    ':gids' => zariz_get_branch_parents_ids($branch_nid),
  );

  $query = '';
  $query .= "SELECT n.nid, n.title, field_uuid.field_uuid_value FROM (select * from node ORDER BY nid DESC) as n ";
  $query .= "INNER JOIN {field_data_field_uuid} field_uuid ON field_uuid.entity_id = n.nid ";
  $query .= "INNER JOIN {og_membership} ogm ON ogm.esid = n.nid ";
  $query .= "WHERE field_uuid.entity_type = 'node' ";

  if ($deleted_nids = zariz_get_deleted_node_ids($branch_nid)) {
    $args[':deleted'] = $deleted_nids;
    $query.= "AND n.nid NOT IN (:deleted) ";
  }

  $query .= "AND ogm.entity_type = 'node' ";
  $query .= "AND ogm.gid IN (:gids) ";
  $query .= "GROUP BY field_uuid.field_uuid_value ";
  $query .= "ORDER BY n.title ASC ";

  $result = db_query($query, $args)
    ->fetchAllAssoc('nid');

  return $result;
}


/**
 * Implements hook_query_branch_context_alter().
 *
 * @see \SelectQuery::__toString
 */
function zariz_query_branch_context_alter(QueryAlterableInterface $query) {
  if (!$query->hasTag('branch_context')) {
    return;
  }

  if (!$og_context = og_context()) {
    return;
  }

  if ($og_context['group_type'] != 'node') {
    return;
  }

  $branch_nid = $og_context['gid'];
  $wrapper = entity_metadata_wrapper('node', $branch_nid);
  $gids = zariz_get_branch_parents_ids($branch_nid);

  $tables = &$query->getTables();

  // Change "FROM" value.
  $form_query = db_select('node', 'n');
  $form_query
    ->fields('n')
    ->orderBy('n.nid', 'DESC');

  $tables['node']['table'] = $form_query;

  // @todo: Remove alias harcoding.
  // @todo: Remove field table hardcoding.
  $query->innerJoin('field_data_field_uuid', 'field_uuid', 'field_uuid.entity_id = node.nid');

  $query
    ->condition('field_uuid.entity_type', 'node')
    ->groupBy('field_uuid.field_uuid_value');


  $query->innerJoin('og_membership', 'ogm', 'ogm.esid = node.nid');
  $query
    ->condition('ogm.entity_type', 'node')
    ->condition('ogm.gid', $gids, 'IN');

  if ($deleted_nids = zariz_get_deleted_node_ids($branch_nid)) {
    $query->condition('node.nid', $deleted_nids, 'NOT IN');
  }

  // Show only up until the last node the branch knows if, if the value exists.
  if ($last_nid = $wrapper->field_last_node->getIdentifier()) {
    $query->condition('node.nid', $last_nid, '<=');
  }
}

/**
 * Implements hook_node_info().
 *
 * Declare the Branch content type.
 */
function zariz_node_info() {
  return array(
    'branch' => array(
      'name' => t('Branch'),
      'description' => t('Branch with content.'),
      'base' => 'node_content',
      'title_label' => t('Name'),
      'has_title' => TRUE,
      'locked' => TRUE,
    ),
  );
}

/**
 * Implements hook_field_create_instance().
 *
 * Add Zariz related fields to group content.
 */
function zariz_field_create_instance($instance) {
  if (!og_is_group_audience_field($instance['field_name'])) {
    // Bundle is not a group content.
    return;
  }

  $entity_type = $instance['entity_type'];
  $bundle = $instance['bundle'];

  // Add "Original branch" field.
  // @todo: Target bundle to "Branch".
  $og_field = og_fields_info(OG_AUDIENCE_FIELD);
  $og_field['field']['cardinality'] = 1;
  $og_field['instance']['label'] = 'Branch';
  $og_field['instance']['required'] = 'TRUE';

  og_create_field('field_branch', $entity_type, $bundle, $og_field);

  // Add "Other branches" field.
  $og_field = og_fields_info(OG_AUDIENCE_FIELD);
  $og_field['field']['cardinality'] = FIELD_CARDINALITY_UNLIMITED;
  $og_field['instance']['label'] = 'All branches';

  og_create_field('field_merged_branches', $entity_type, $bundle, $og_field);

  // Add "UUID" field.
  $field_name = 'field_uuid';

  if (!field_info_field($field_name)) {
    $field = array(
      'cardinality' => 1,
      'entity_types' => array(),
      'field_name' => $field_name,
      'module' => 'text',
      'type' => 'text',
    );
    field_create_field($field);
  }

  if (!field_info_instance($instance['entity_type'], $field_name, $instance['bundle'])) {
    $instance = array(
      'entity_type' => $entity_type,
      'field_name' => $field_name,
      'bundle' => $bundle,
      'label' => 'UUID',
      'description' => 'Unique ID.',
      'widget' => array(
        'active' => 1,
        'module' => 'text',
        'type' => 'text',
      ),
    );
    field_create_instance($instance);
  }

  // Add "Deleted snapshot" field.
  $field_name = 'field_deleted_snapshots';
  if (!field_info_field($field_name)) {
    $field = array(
      'entity_types' => array(),
      'settings' => array(
        'handler' => 'base',
        'target_type' => 'snapshot',
        'handler_settings' => array(
          'target_bundles' => array(),
        ),
      ),
      'field_name' => $field_name,
      'type' => 'entityreference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
    );
    field_create_field($field);
  }

  if (!field_info_instance('node', $field_name, 'branch')) {
    $instance = array(
      'entity_type' => $entity_type,
      'field_name' => $field_name,
      'bundle' => $bundle,
      'label' => 'Deleted snapshots',
    );
    field_create_instance($instance);
  }

}
