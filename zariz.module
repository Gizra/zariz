<?php

/**
 * @file
 * Content Revision Control.
 */

/**
 * Implements hook_entity_info().
 */
function zariz_entity_info() {
  $items['snapshot'] = array(
    'label' => t('Snapshot'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'Snapshot',
    'base table' => 'zariz_snapshot',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'tid',
    ),
    'bundles' => array(
      'snapshot' => array(
        'label' => t('Snapshot'),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
    ),
    'module' => 'zariz',
    'metadata controller class' => 'EntityDefaultMetadataController',
  );
  return $items;
}


/**
 * Create a new branch form an existing one.
 *
 * @param $branch_name
 *   The branch name.
 * @param $original_branch
 *   Optional; The node ID or object of the original branch.
 */
function zariz_create_branch($branch_name, $original_branch = FALSE) {
  global $user;

  // Check branch doesn't exist already.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'branch')
    ->propertyCondition('title', $branch_name)
    ->count()
    ->execute();

  if ($result) {
    throw new Exception(format_string('Branch @name already exists', array('@name' => $branch_name)));
  }

  $values = array(
    'type' => 'branch',
    'title' => $branch_name,
    'uid' => $user->uid,
  );
  $node = entity_create('node', $values);

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->{OG_GROUP_FIELD}->set(TRUE);

  if ($original_branch) {
    $branch_wrapper = entity_metadata_wrapper('node', $original_branch);
    $branch_id = $branch_wrapper->getIdentifier();

    $wrapper->field_branch->set($original_branch);

    // Get the last snapshot created in the original branch.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'snapshot')
      ->fieldCondition('nid', $branch_id)
      ->range(0, 1)
      ->propertyOrderBy('tid', 'DESC')
      ->execute();

    if (!empty($result['snapshot'])) {
      $tid = key($result['snapshot']);
      $wrapper->field_snapshot->set($tid);
    }
  }

  $wrapper->save();
  return $wrapper->value();
}

/**
 * Include new content from the parent branch.
 *
 * As we do not duplicate content between branches, we simply update the "Last
 * node" field to point to the latest node in the parent branch.
 *
 * @param $branch_nid
 *   The branch node ID or object.
 */
function zariz_update_content_from_parent_branch($branch_nid) {
  $wrapper = entity_metadata_wrapper('node', $branch_nid);

  if (!$parent_id = $wrapper->field_branch->getIdentifier()) {
    // Nothing to update, as the branch has no parent.
    return;
  }

  // Get the last node ID.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $parent_id)
    ->range(0, 1)
    ->propertyOrderBy('nid', 'DESC')
    ->execute();

  if (empty($result['node'])) {
    // Parent branch has no content.
    return;
  }

  $last_nid = key($result['node']);
  $wrapper->field_last_node->set($last_nid);
  $wrapper->save();
}

/**
 * Get the node IDs of the parents of the branch, including the node itself.
 *
 * @param $branch_nid
 *   The branch ID or node.
 * @param $include_current
 *   Determines if the current branch should be included. Defaults to TRUE.
 * @param $ids
 *   Internal use; Array of the parent IDs, used in this recursive function.
 *
 * @return
 *   array with the branch node ID, and it's parents. The top most parent is the
 *   last element in the array.
 */
function zariz_get_branch_parents_ids($branch_nid, $include_current = TRUE, $ids = array()) {
  $wrapper = entity_metadata_wrapper('node', $branch_nid);

  $ids = array();
  if (!$ids && $include_current) {
    $branch_node = $wrapper->value();
    $ids[] = $branch_node->nid;
  }


  if (!$parent_node = $wrapper->field_branch->value()) {
    // We reached the top most parent.
    return $ids;
  }

  // Call function, with the parent node.
  $ids = zariz_get_branch_parents_ids($parent_node, $include_current, $ids);
  return $ids;
}

/**
 * Get the snapshot IDs of the parents of the snapshot, including the snapshot itself.
 *
 * @param $snapshot_id
 *   The branch ID or node.
 * @param $strict_snapshot
 *   Determines if the parent snapshot should be the real parent snapshot, or
 *   the last snapshot the exists in the Branch. If using the last snapshot then
 *   the returned values will include content that was inserted or deleted after
 *   the branch was created. If TRUE, then only the content that was created
 *   exactly when the branch was created will be show. Defaults to FALSE.
 *
 * @return
 *   array with the snapshot ID, and it's parents. The top most parent is the
 *   last element in the array.
 */
function zariz_get_snapshot_parents_ids($snapshot_id, $strict_snapshot = FALSE) {
  if ($strict_snapshot) {
    return zariz_get_snapshot_parents_ids_strict($snapshot_id);
  }

  return zariz_get_snapshot_parents_ids_not_strict($snapshot_id);
}


/**
 * Helper function; Return the snapshot parents in strict mode.
 *
 * @param $snapshot_id
 *   The branch ID or node.
 * @param $ids
 *   Internal use. Array of the parent IDs, used in this recursive function.
 *
 * @return
 *   array with the snapshot ID, and it's parents. The top most parent is the
 *   last element in the array.
 *
 * @see zariz_get_snapshot_parents_ids().
 */
function zariz_get_snapshot_parents_ids_strict($snapshot_id, $ids = array()) {
  $wrapper = entity_metadata_wrapper('snapshot', $snapshot_id);
  $ids[] = $snapshot_id;

  if (!$parent_snapshot = $wrapper->field_snapshot->value()) {
    // We reached the top most parent.
    return $ids;
  }

  // Call function, with the parent snapshot.
  $ids = zariz_get_snapshot_parents_ids($parent_snapshot, $ids);
  return $ids;
}

/**
 * Helper function; Return the snapshot parents in a non-strict mode.
 *
 * @param $snapshot_id
 *   The branch ID or node.
 * @param $ids
 *   Internal use. Array of the parent IDs, used in this recursive function.
 *
 * @return
 *   array with the snapshot ID, and it's parents. The top most parent is the
 *   last element in the array.
 *
 * @see zariz_get_snapshot_parents_ids().
 */
function zariz_get_snapshot_parents_ids_not_strict($snapshot_id, $ids = array()) {
  // Get all the parent branches.

  $ids = array($snapshot_id);
  $snapshot = entity_load_single('snapshot', $snapshot_id);
  $branch_ids = zariz_get_branch_parents_ids($snapshot->nid, FALSE);

  foreach ($branch_ids as $branch_id) {
    if ($snapshot = zariz_get_snapshot_from_branch($branch_id)) {
      $ids[] = $snapshot->tid;
    }
  }

  return $ids;
}

/**
 * Return array with all the content by a snapshot and its parents.
 *
 * @param $snapshot_id
 *   The snapshot ID.
 * @param $entity_type
 *   The entity type to return. Defaults to "node".
 * @param $strict_snapshot
 *   Determines if the parent snapshot should be the real parent snapshot, or
 *   the last snapshot the exists in the Branch. If using the last snapshot then
 *   the returned values will include content that was inserted or deleted after
 *   the branch was created. If TRUE, then only the content that was created
 *   exactly when the branch was created will be show. Defaults to FALSE.
 *
 * @return
 *   Array keyed with the UUID and array with entity ID and URI as value.
 */
function zariz_get_all_content_by_snapshot($snapshot_id, $entity_type = 'node', $strict_snapshot = FALSE) {
  $tids = zariz_get_snapshot_parents_ids($snapshot_id, $strict_snapshot);

  $snapshots = entity_load('snapshot', $tids);

  $return[$entity_type] = array();
  foreach ($snapshots as $snapshot) {
    if (!empty($snapshot->data['insert'][$entity_type])) {
      $return[$entity_type] = drupal_array_merge_deep($return[$entity_type], $snapshot->data['insert'][$entity_type]);
    }

    if (!empty($snapshot->data['delete'][$entity_type])) {
      // Remove deleted items.
      foreach ($snapshot->data[$entity_type]['delete'] as $uuid) {
        unset($return[$entity_type][$uuid]);
      }
    }
  }

  return $return;
}

/**
 * Get the node IDs of "deleted" nodes, that should be excluded.
 *
 * @param $branch_nid
 *   The branch node.
 * @return
 *   array with the node IDs.
 */
function zariz_get_deleted_node_ids($branch_nid) {
  $branch_ids = zariz_get_branch_parents_ids($branch_nid);

  // Get all the deleted node IDs in the branches.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->fieldCondition('field_deleted', 'value', TRUE)
    ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $branch_ids, 'IN')
    ->execute();

  if (empty($result['node'])) {
    return array();
  }

  // Load all the deleted nodes, to get their UUID, so we can exclude also their
  // non-deleted version.
  $uuids = array();
  foreach (node_load_multiple(array_keys($result['node'])) as $node) {
    $wrapper = entity_metadata_wrapper('node', $node);
    $uuid = $wrapper->field_uuid->value();
    $uuids[$uuid] = TRUE;
  }

  // Now query for the nodes, based on the UUID in the parent branches.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    // @todo: Remove hardcoding to article
    ->entityCondition('bundle', 'article')
    ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $branch_ids, 'IN')
    ->fieldCondition('field_uuid', 'value', array_keys($uuids), 'IN')
    ->execute();

  return array_keys($result['node']);
}

/**
 * Implements hook_field_access().
 */
function zariz_field_access($op, $field, $entity_type, $entity, $account) {
  if ($op == 'edit' && $field['field_name'] == 'field_uuid') {
    return FALSE;
  }
}

/**
 * Implements hook_node_presave().
 *
 * Populate a unique ID value.
 */
function zariz_node_presave($node) {
  if (!empty($node->nid)) {
    return;
  }

  if (!og_is_group_content_type('node', $node->type)) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if (!$uuid = $wrapper->field_uuid->value()) {
    // UUID doesn't exist.
    $uuid = md5(rand());
    $wrapper->field_uuid->set($uuid);
  }
}

/**
 * Implements hook_node_insert().
 *
 * Add node to branch's flag.
 */
function zariz_node_insert($node) {
  if (!og_is_group_content_type('node', $node->type)) {
    // Not a group content.
    return;
  }

  if (!empty($node->_skip_create_snapshot)) {
    // Node explicetly set to skip snapshot creation. This can be used by
    // implementing modules that want for example to create several nodes and
    // only then create a snapshot of them.
    return;
  }

  // Add node to snapshot.
  $wrapper = entity_metadata_wrapper('node', $node);
  $branch_id = $wrapper->{OG_AUDIENCE_FIELD}->getIdentifier();

  $insert = array('node' => array($node));
  zariz_create_snapshot($branch_id, $insert);
}

/**
 * Returns the latest snapshot object of a branch.
 *
 * @param $branch_id
 *   The branch ID.
 * @param $offset
 *   The offest from the latest snapshot. Defaults to 0, which is the latest
 *   snapshot created.
 *
 * @return
 *   The Snapshot entity object, or FALSE.
 *
 */
function zariz_get_snapshot_from_branch($branch_id, $offset = 0) {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'snapshot')
    ->propertyCondition('nid', $branch_id)
    ->range($offset, $offset + 1)
    ->propertyOrderBy('tid', 'DESC')
    ->execute();

  if (empty($result['snapshot'])) {
    return FALSE;
  }

  $tid = key($result['snapshot']);
  return entity_load_single('snapshot', $tid);
}

/**
 * Add or remove entities from a Snapshot entity.
 *
 * This creates a snapshot of the content on a specific "revision".
 *
 * @param $branch_id
 *   The branch node ID.
 * @param $insert
 *   Array of entities objects to "insert", keyed by entity type.
 * @param $delete
 *   Array of entities objects to "delete", keyed by entity type.
 * @param $use_existing
 *   Determines if an existing snapshot should be used, or a new one created.
 *   Defaults to TRUE.
 * @param $overwrite
 *   If $use_existing is set to TRUE, and there is an existing snapshot, then
 *   the values would be added or removed from the existing values, rather then
 *   overwriting them.
 *   Defaults to FALSE.
 *
 * @return Snapshot
 *   Returns a Snapshot entity object.
 */
function zariz_create_snapshot($branch_id, $insert = array(), $delete = array(), $use_existing = TRUE, $overwrite = FALSE) {
  if ($use_existing) {
    $snapshot = zariz_get_snapshot_from_branch($branch_id);
    // If we are trying to use an existing snapshot, then the parent should be
    // retrieved using zariz_get_snapshot_from_branch() with an offset of 1.
    $offset = 1;
  }
  else {
    $offset = 0;
  }

  if (!$parent_snapshot = zariz_get_snapshot_from_branch($branch_id, $offset)) {
    // Get snapshot from branch, if exists.
    $wrapper = entity_metadata_wrapper('node', $branch_id);
    $parent_snapshot = $wrapper->field_snapshot->value();
  }

  $data = array();
  if ($snapshot && !$overwrite) {
    // Use the existing data.
    $data = $snapshot->data;
  }

  // Prepare the new data.
  foreach ($insert as $entity_type => $entities) {
    foreach ($entities as $entity) {
      $wrapper = entity_metadata_wrapper($entity_type, $entity);
      $uuid = $wrapper->field_uuid->value();
      $id = $wrapper->getIdentifier();

      $uri = entity_uri($entity_type, $entity);

      // Save the entity, keyed by UUID with the entity ID and the URI as the
      // value.
      $data['insert'][$entity_type][$uuid] = array(
        'id' => $id,
        'uri' => $uri['path'],
      );

      // Remove it from the "delete" if it was there.
      unset($data['delete'][$entity_type][$uuid]);
    }
  }

  foreach ($delete as $entity_type => $entities) {
    foreach ($entities as $entity) {
      $wrapper = entity_metadata_wrapper($entity_type, $entity);
      $uuid = $wrapper->field_uuid->value();
      $id = $wrapper->getIdentifier();

      $data['delete'][$entity_type][$uuid] = $id;

      // Remove it from the "insert" if it was there.
      unset($data['insert'][$entity_type][$uuid]);
    }
  }

  if (!$snapshot) {
    // Create a new snapshot.
    $values = array(
      'nid' => $branch_id,
      'data' => $data,
      'parent_tid' => $parent_snapshot ? $parent_snapshot->tid : NULL,
      'created' => time(),
    );
    $snapshot = entity_create('snapshot', $values);
  }
  else {
    // Update the data of the existing snapshot.
    $snapshot->data = $data;
  }

  $snapshot->save();
  return $snapshot;
}

/**
 * Implements hook_node_update().
 *
 * Safe guard against updating group content nodes.
 */
function zariz_node_update($node) {
  if (!og_is_group_content_type('node', $node->type)) {
    // Not a group content.
    return;
  }

  if (!empty($node->_allow_save)) {
    // Allow forcing update (e.g. when updating the git hash).
    return;
  }

  throw new Exception(format_string('Node @title cannot be updated -  a new node should have been created instead.', array('@title' => $node->title)));
}

/**
 * Implements hook_node_delete().
 *
 * Safe guard against deleting any node.
 */
function zariz_node_delete($node) {
  throw new Exception('It is illegal to delete a node.');
}

/**
 * Implements hook_clone_node_alter().
 *
 * Preserve the original node title on clone, and set the branch by context.
 */
function zariz_clone_node_alter($node, $context) {
  if ($context['method'] != 'prepopulate') {
    return;
  }

  if (!$og_context = og_context()) {
    // Safe guard against a failure of PURL to redirect to a group.
    // @todo: Check if this can really happen.
    throw new Exception('Cloning content should be inside a branch context.');
  }


  // Use the original node title.
  $node->title = $context['original_node']->title;

  // Check the context is a child of the existing branch.
  $wrapper = entity_metadata_wrapper('node', $node);
  $new_branch_wrapper = entity_metadata_wrapper('node', $og_context['gid']);

  if ($wrapper->{OG_AUDIENCE_FIELD}->getIdentifier() == $og_context['gid']) {
    // We are cloning inside the same branch, which is the only way to update
    // an existing node.
    return;
  }

  if ($new_branch_wrapper->field_branch->getIdentifier() != $wrapper->{OG_AUDIENCE_FIELD}->getIdentifier()) {
    $params = array(
      '@origin' => $wrapper->{OG_AUDIENCE_FIELD}->label(),
      '@destination' => $new_branch_wrapper->label(),
    );
    throw new Exception(format_string('Cannot clone content from branch @origin to @destination as it was not branched from it.', $params));
  }

  // Set the group audience field according to the existing context. Like this
  // we allow "cherry-picking" content from branch to branch.
  $wrapper->{OG_AUDIENCE_FIELD}->set($og_context['gid']);
}


/**
 * Get all nodes of a branch, even if they are not directly in the group.
 *
 * We query for the branch, and the parent branches.
 *
 * @param $branch_nid
 *   A branch node ID. If NULL, OG-context will be triggered to get the current
 *   branch.
 */
function gznt_rn_get_branch_nodes($branch_nid = NULL) {
  if (!$branch_nid && !$og_context = og_context()) {
    throw new Exception('No branch node found to limit the entity field query.');
  }
  $args = array(
    ':gids' => zariz_get_branch_parents_ids($branch_nid),
  );

  $query = '';
  $query .= "SELECT n.nid, n.title, field_uuid.field_uuid_value FROM (select * from node ORDER BY nid DESC) as n ";
  $query .= "INNER JOIN {field_data_field_uuid} field_uuid ON field_uuid.entity_id = n.nid ";
  $query .= "INNER JOIN {og_membership} ogm ON ogm.etid = n.nid ";
  $query .= "WHERE field_uuid.entity_type = 'node' ";

  if ($deleted_nids = zariz_get_deleted_node_ids($branch_nid)) {
    $args[':deleted'] = $deleted_nids;
    $query.= "AND n.nid NOT IN (:deleted) ";
  }

  $query .= "AND ogm.entity_type = 'node' ";
  $query .= "AND ogm.gid IN (:gids) ";
  $query .= "GROUP BY field_uuid.field_uuid_value ";
  $query .= "ORDER BY n.title ASC ";

  $result = db_query($query, $args)
    ->fetchAllAssoc('nid');

  return $result;
}


/**
 * Implements hook_query_branch_context_alter().
 *
 * @see \SelectQuery::__toString
 */
function zariz_query_branch_context_alter(QueryAlterableInterface $query) {
  if (!$query->hasTag('branch_context')) {
    return;
  }

  if (!$og_context = og_context()) {
    return;
  }

  if ($og_context['group_type'] != 'node') {
    return;
  }

  $branch_nid = $og_context['gid'];
  $wrapper = entity_metadata_wrapper('node', $branch_nid);
  $gids = zariz_get_branch_parents_ids($branch_nid);

  $tables = &$query->getTables();

  // Change "FROM" value.
  $form_query = db_select('node', 'n');
  $form_query
    ->fields('n')
    ->orderBy('n.nid', 'DESC');

  $tables['node']['table'] = $form_query;

  // @todo: Remove alias harcoding.
  // @todo: Remove field table hardcoding.
  $query->innerJoin('field_data_field_uuid', 'field_uuid', 'field_uuid.entity_id = node.nid');

  $query
    ->condition('field_uuid.entity_type', 'node')
    ->groupBy('field_uuid.field_uuid_value');


  $query->innerJoin('og_membership', 'ogm', 'ogm.etid = node.nid');
  $query
    ->condition('ogm.entity_type', 'node')
    ->condition('ogm.gid', $gids, 'IN');

  if ($deleted_nids = zariz_get_deleted_node_ids($branch_nid)) {
    $query->condition('node.nid', $deleted_nids, 'NOT IN');
  }

  // Show only up until the last node the branch knows if, if the value exists.
  if ($last_nid = $wrapper->field_last_node->getIdentifier()) {
    $query->condition('node.nid', $last_nid, '<=');
  }
}

/**
 * Implements hook_node_info().
 *
 * Declare the Branch content type.
 */
function zariz_node_info() {
  return array(
    'branch' => array(
      'name' => t('Branch'),
      'description' => t('Branch with content.'),
      'base' => 'node_content',
      'title_label' => t('Name'),
      'has_title' => TRUE,
      'locked' => TRUE,
    ),
  );
}

/**
 * Implements hook_field_create_instance().
 *
 * Add UUID field to group content.
 */
function zariz_field_create_instance($instance) {
  if (!og_is_group_audience_field($instance['field_name'])) {
    // Bundle is not a group content.
    return;
  }

  $field_name = 'field_uuid';

  if (!field_info_field($field_name)) {
    $field = array(
      'cardinality' => '1',
      'entity_types' => array(),
      'field_name' => $field_name,
      'module' => 'text',
      'type' => 'text',
    );
    field_create_field($field);
  }

  if (!field_info_instance($instance['entity_type'], $field_name, $instance['bundle'])) {
    $instance = array(
      'entity_type' => $instance['entity_type'],
      'field_name' => $field_name,
      'bundle' => $instance['bundle'],
      'label' => 'UUID',
      'description' => 'Unique ID.',
      'widget' => array(
        'active' => 1,
        'module' => 'text',
        'type' => 'text',
      ),
    );
    field_create_instance($instance);
  }
}
